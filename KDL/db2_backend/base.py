import pyodbc
from django.db.backends.base.base import BaseDatabaseWrapper
from django.db.backends.base.client import BaseDatabaseClient
from django.db.backends.base.creation import BaseDatabaseCreation
from django.db.backends.base.introspection import BaseDatabaseIntrospection
from django.db.backends.base.operations import BaseDatabaseOperations

from . import features
from . import introspection
from . import operations
from . import schema


class DB2CursorWrapper:
    """
    Обертка для курсора pyodbc для работы с Django ORM.
    Заменяет %s на ? и добавляет CAST для параметров DB2.
    """

    def __init__(self, cursor):
        self._cursor = cursor
        self._original_execute = cursor.execute
        self._original_executemany = cursor.executemany

    def __getattr__(self, name):
        # Делегируем все остальные атрибуты оригинальному курсору
        return getattr(self._cursor, name)

    def execute(self, sql, params=None):
        """Выполняет SQL с заменой %s на ? и CAST для DB2"""
        if params is not None:
            # Заменяем %s на ? для DB2
            if isinstance(sql, str):
                sql = sql.replace('%s', '?')

            # Добавляем CAST для параметров если нужно
            sql = self._add_cast_for_params(sql, params)

            return self._original_execute(sql, params)
        else:
            return self._original_execute(sql)

    def executemany(self, sql, params_list):
        """Выполняет SQL много раз"""
        if params_list and isinstance(sql, str):
            sql = sql.replace('%s', '?')
        return self._original_executemany(sql, params_list)

    def _add_cast_for_params(self, sql, params):
        """
        Добавляет CAST к параметрам в SQL для DB2
        В DB2 нужно явно указывать типы для параметров
        """
        if not params:
            return sql

        import re
        from datetime import date, datetime

        # Находим все ? в запросе
        question_marks = [m.start() for m in re.finditer(r'\?', sql)]

        if len(question_marks) != len(params):
            return sql  # Не можем обработать

        # Собираем новый SQL с CAST
        parts = []
        last_pos = 0

        for i, pos in enumerate(question_marks):
            # Добавляем текст до ?
            parts.append(sql[last_pos:pos])

            # Определяем тип параметра
            param = params[i]
            if isinstance(param, (date, datetime)):
                parts.append("CAST(? AS DATE)")
            elif isinstance(param, str):
                # Для строк можно указать максимальную длину
                parts.append("CAST(? AS VARCHAR(1000))")
            elif isinstance(param, int):
                parts.append("CAST(? AS INTEGER)")
            elif isinstance(param, float):
                parts.append("CAST(? AS DOUBLE)")
            else:
                parts.append("?")

            last_pos = pos + 1

        # Добавляем оставшийся текст
        parts.append(sql[last_pos:])

        return ''.join(parts)


class DatabaseWrapper(BaseDatabaseWrapper):
    vendor = 'ibm'
    display_name = 'DB2'

    Database = pyodbc
    features_class = features.DatabaseFeatures
    introspection_class = introspection.DatabaseIntrospection
    ops_class = operations.DatabaseOperations
    client_class = BaseDatabaseClient
    creation_class = BaseDatabaseCreation
    schema_editor_class = schema.DatabaseSchemaEditor

    # Операторы для ORM
    operators = {
        'exact': '= %s',
        'iexact': 'LIKE UPPER(%s)',
        'contains': 'LIKE %s',
        'icontains': 'LIKE UPPER(%s)',
        'gt': '> %s',
        'gte': '>= %s',
        'lt': '< %s',
        'lte': '<= %s',
        'startswith': 'LIKE %s',
        'endswith': 'LIKE %s',
        'istartswith': 'LIKE UPPER(%s)',
        'iendswith': 'LIKE UPPER(%s)',
    }

    # Типы данных
    data_types = {
        'AutoField': 'INTEGER GENERATED BY DEFAULT AS IDENTITY',
        'BigAutoField': 'BIGINT GENERATED BY DEFAULT AS IDENTITY',
        'BinaryField': 'BLOB',
        'BooleanField': 'SMALLINT',
        'CharField': 'VARCHAR(%(max_length)s)',
        'DateField': 'DATE',
        'DateTimeField': 'TIMESTAMP',
        'DecimalField': 'DECIMAL(%(max_digits)s, %(decimal_places)s)',
        'DurationField': 'BIGINT',
        'FileField': 'VARCHAR(%(max_length)s)',
        'FilePathField': 'VARCHAR(%(max_length)s)',
        'FloatField': 'DOUBLE',
        'IntegerField': 'INTEGER',
        'BigIntegerField': 'BIGINT',
        'IPAddressField': 'CHAR(15)',
        'GenericIPAddressField': 'CHAR(39)',
        'NullBooleanField': 'SMALLINT',
        'OneToOneField': 'INTEGER',
        'PositiveIntegerField': 'INTEGER',
        'PositiveSmallIntegerField': 'SMALLINT',
        'SlugField': 'VARCHAR(%(max_length)s)',
        'SmallIntegerField': 'SMALLINT',
        'TextField': 'CLOB',
        'TimeField': 'TIME',
        'UUIDField': 'CHAR(32)',
    }

    data_type_check_constraints = {
        'BooleanField': '%(qn_column)s IN (0,1)',
        'NullBooleanField': '(%(qn_column)s IN (0,1)) OR (%(qn_column)s IS NULL)',
        'PositiveIntegerField': '%(qn_column)s >= 0',
        'PositiveSmallIntegerField': '%(qn_column)s >= 0',
    }

    pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
    pattern_ops = {
        'contains': "LIKE '%%' || {} || '%%'",
        'icontains': "LIKE '%%' || UPPER({}) || '%%'",
        'startswith': "LIKE {} || '%%'",
        'istartswith': "LIKE UPPER({}) || '%%'",
        'endswith': "LIKE '%%' || {}",
        'iendswith': "LIKE '%%' || UPPER({})",
    }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Инициализация компонентов
        self.ops = self.ops_class(self)
        self.features = self.features_class(self)
        self.introspection = self.introspection_class(self)
        self.creation = self.creation_class(self)

    def get_connection_params(self):
        settings_dict = self.settings_dict
        conn_params = settings_dict.get('OPTIONS', {}).copy()

        conn_str = conn_params.pop('connection_string', None)
        if not conn_str:
            server = settings_dict.get('HOST', 'localhost')
            database = settings_dict.get('NAME', '')
            port = settings_dict.get('PORT', '50000')
            uid = settings_dict.get('USER', '')
            pwd = settings_dict.get('PASSWORD', '')

            conn_str = (
                f"DRIVER={{IBM DB2 ODBC DRIVER}};"
                f"DATABASE={database};"
                f"HOSTNAME={server};"
                f"PORT={port};"
                f"PROTOCOL=TCPIP;"
                f"UID={uid};"
                f"PWD={pwd};"
            )

        conn_params.update({
            'autocommit': False,
            'timeout': conn_params.get('timeout', 30),
            'unicode_results': True,
        })

        return conn_str, conn_params

    def get_new_connection(self, conn_params):
        connection_string, params = conn_params
        try:
            connection = pyodbc.connect(connection_string, **params)

            # ⬇️ КРИТИЧЕСКИ ВАЖНО: Установите правильную кодировку ⬇️
            # Для DB2 с русскими данными в CP1251
            connection.setdecoding(pyodbc.SQL_CHAR, encoding='cp1251')
            connection.setdecoding(pyodbc.SQL_WCHAR, encoding='cp1251')
            connection.setencoding(encoding='cp1251')

            # Также можно попробовать с utf-8 для новых данных
            # connection.setdecoding(pyodbc.SQL_CHAR, encoding='utf-8')
            # connection.setdecoding(pyodbc.SQL_WCHAR, encoding='utf-8')
            # connection.setencoding(encoding='utf-8')

            return connection
        except pyodbc.Error as e:
            from django.db import Error
            raise Error(f"Failed to connect to DB2: {e}")

    def create_cursor(self, name=None):
        """Создает курсор с оберткой для работы с Django ORM"""
        cursor = self.connection.cursor()
        return DB2CursorWrapper(cursor)

    def make_debug_cursor(self, cursor):
        from django.db.backends.utils import CursorDebugWrapper
        # Для отладочного курсора нужно получить оригинальный курсор
        if hasattr(cursor, '_cursor'):
            cursor = cursor._cursor
        return CursorDebugWrapper(cursor, self)

    def _set_autocommit(self, autocommit):
        self.connection.autocommit = autocommit

    def init_connection_state(self):
        pass

    def is_usable(self):
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("SELECT 1 FROM SYSIBM.SYSDUMMY1")
                cursor.fetchone()
            return True
        except pyodbc.Error:
            return False

    def _start_transaction_under_autocommit(self):
        pass
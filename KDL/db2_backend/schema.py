from django.db.backends.base.schema import BaseDatabaseSchemaEditor
import re


class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
    sql_create_table = "CREATE TABLE %(table)s (%(columns)s)"
    sql_delete_table = "DROP TABLE %(table)s"
    sql_create_column = "ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s"
    sql_alter_column = "ALTER TABLE %(table)s ALTER COLUMN %(column)s %(changes)s"
    sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s"
    sql_rename_table = "RENAME TABLE %(old_table)s TO %(new_table)s"
    sql_rename_column = "RENAME COLUMN %(table)s.%(old_column)s TO %(new_column)s"

    sql_create_check = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)"
    sql_delete_check = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"

    sql_create_unique = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)"
    sql_delete_unique = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"

    sql_create_fk = (
        "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) "
        "REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s"
    )
    sql_delete_fk = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"

    sql_create_index = "CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s"
    sql_delete_index = "DROP INDEX %(name)s"

    sql_create_pk = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)"
    sql_delete_pk = "ALTER TABLE %(table)s DROP PRIMARY KEY"

    def quote_value(self, value):
        if isinstance(value, bool):
            return "1" if value else "0"
        elif isinstance(value, str):
            return "'%s'" % value.replace("'", "''")
        elif value is None:
            return "NULL"
        else:
            return str(value)

    def _model_indexes_sql(self, model):
        """Генерирует SQL для индексов модели"""
        return []

    def _create_index_name(self, table_name, column_names, suffix=""):
        """Создает имя индекса в соответствии с ограничениями DB2"""
        hash_data = [table_name] + list(column_names)
        hash_suffix = '_%s' % self._digest(*hash_data)
        max_length = self.connection.ops.max_name_length() or 128

        # Если имя слишком длинное, укорачиваем его
        name = '%s_%s%s%s' % (table_name, '_'.join(column_names), suffix, hash_suffix)
        if len(name) > max_length:
            name = name[:max_length]
        return name

    def _digest(self, *args):
        """Создает хеш для имен объектов"""
        import hashlib
        h = hashlib.md5()
        for arg in args:
            h.update(arg.encode())
        return h.hexdigest()[:8]

    def prepare_default(self, value):
        """Подготовка значения по умолчанию"""
        if isinstance(value, bool):
            return str(int(value))
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, str):
            return "'%s'" % value.replace("'", "''")
        elif value is None:
            return "NULL"
        else:
            return value

    def column_sql(self, model, field, include_default=False):
        """Генерирует SQL для колонки"""
        from django.db import connection

        db_params = field.db_parameters(connection=connection)
        sql = db_params['type']
        params = []

        # Обработка null/not null
        if field.null:
            sql += " NULL"
        else:
            sql += " NOT NULL"

        # Значение по умолчанию
        if include_default:
            default_value = self.effective_default(field)
            if default_value is not None:
                sql += " DEFAULT %s"
                params.append(self.prepare_default(default_value))

        # Автоинкремент
        if field.auto_increment:
            sql += " GENERATED BY DEFAULT AS IDENTITY"

        return sql, params

    def skip_default(self, field):
        """Проверяет, нужно ли пропускать значение по умолчанию"""
        return (
                field.null or
                field.db_default is not None or
                field.auto_increment or
                (field.db_comment is not None and field.db_comment != '')
        )